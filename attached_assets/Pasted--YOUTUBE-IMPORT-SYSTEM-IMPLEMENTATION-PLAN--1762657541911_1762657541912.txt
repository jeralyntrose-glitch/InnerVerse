â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
YOUTUBE IMPORT SYSTEM - IMPLEMENTATION PLAN
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

GOAL: Import YouTube URLs from extracted .txt files and intelligently match them to existing or future PDF transcripts

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
STEP 1: DATABASE SCHEMA
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Add columns to existing documents table:

ALTER TABLE documents ADD COLUMN youtube_url TEXT;
ALTER TABLE documents ADD COLUMN youtube_video_id TEXT;
ALTER TABLE documents ADD COLUMN youtube_duration TEXT;

Create new table for pending videos (not yet matched to PDFs):

CREATE TABLE pending_youtube_videos (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    video_title TEXT NOT NULL,
    youtube_url TEXT NOT NULL,
    youtube_video_id TEXT NOT NULL,
    playlist_name TEXT,
    season_number TEXT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    matched_to_document_id INTEGER,
    FOREIGN KEY (matched_to_document_id) REFERENCES documents(id)
);

CREATE INDEX idx_pending_video_title ON pending_youtube_videos(video_title);
CREATE INDEX idx_pending_matched ON pending_youtube_videos(matched_to_document_id);

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
STEP 2: IMPORT SCRIPT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

File: scripts/import_youtube_urls.py

FUNCTIONALITY:
1. Read all .txt files from a specified folder
2. Parse each file to extract video titles and URLs
3. Extract video ID from URL (everything after watch?v=)
4. Try to match each video to existing documents in database
5. If match found â†’ update document with YouTube URL
6. If no match â†’ store in pending_youtube_videos table
7. Generate detailed report

MATCHING ALGORITHM:
- Normalize both strings (lowercase, remove special chars, collapse whitespace)
- Try exact match first
- Try fuzzy match with similarity threshold (80%+)
- Match on key phrases (season number, topic keywords)

EXAMPLE MATCHES:
PDF filename: "Season 17.2 - Crusader (ENTP, INTP, ESFJ, ISFJ) Ab.pdf"
Video title: "Alpha Quadra - Crusader Abusers - Relationship Dynamics"
Match score: 75% (season 17, "crusader" appears in both)

CODE STRUCTURE:

import sqlite3
import re
from pathlib import Path
from difflib import SequenceMatcher

class YouTubeImporter:
    def __init__(self, db_path='innerverse.db'):
        self.db = sqlite3.connect(db_path)
        self.matched = []
        self.pending = []
        
    def parse_txt_file(self, filepath):
        """Parse a .txt file and extract video data"""
        with open(filepath, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # First line is playlist name
        lines = content.strip().split('\n')
        playlist_name = lines[0] if lines else 'Unknown Playlist'
        
        # Extract season number from playlist name
        season_match = re.search(r'Season (\d+\.?\d*)', playlist_name, re.IGNORECASE)
        season_number = season_match.group(1) if season_match else None
        
        # Parse videos (skip first line)
        videos = []
        for line in lines[2:]:  # Skip playlist name and blank line
            if not line.strip():
                continue
            
            # Split on last occurrence of ' - https://'
            parts = line.rsplit(' - https://', 1)
            if len(parts) == 2:
                title = parts[0].strip()
                url = 'https://' + parts[1].strip()
                video_id = self.extract_video_id(url)
                
                videos.append({
                    'title': title,
                    'url': url,
                    'video_id': video_id,
                    'playlist_name': playlist_name,
                    'season_number': season_number
                })
        
        return videos
    
    def extract_video_id(self, url):
        """Extract video ID from YouTube URL"""
        match = re.search(r'[?&]v=([^&]+)', url)
        return match.group(1) if match else url.split('/')[-1]
    
    def normalize_string(self, s):
        """Normalize string for matching"""
        # Lowercase
        s = s.lower()
        # Remove special characters except spaces and dashes
        s = re.sub(r'[^\w\s-]', '', s)
        # Collapse whitespace
        s = re.sub(r'\s+', ' ', s)
        return s.strip()
    
    def calculate_similarity(self, str1, str2):
        """Calculate similarity between two strings"""
        norm1 = self.normalize_string(str1)
        norm2 = self.normalize_string(str2)
        return SequenceMatcher(None, norm1, norm2).ratio()
    
    def find_matching_document(self, video):
        """Try to find existing document that matches this video"""
        cursor = self.db.cursor()
        
        # Get all documents
        cursor.execute("SELECT id, filename FROM documents")
        documents = cursor.fetchall()
        
        best_match = None
        best_score = 0.0
        
        for doc_id, filename in documents:
            # Calculate similarity
            score = self.calculate_similarity(video['title'], filename)
            
            # Bonus points if season numbers match
            if video['season_number']:
                if f"season {video['season_number']}" in filename.lower():
                    score += 0.1
                if f"[{video['season_number']}]" in filename.lower():
                    score += 0.1
            
            if score > best_score:
                best_score = score
                best_match = doc_id
        
        # Return match if score is high enough
        if best_score >= 0.70:  # 70% similarity threshold
            return best_match, best_score
        
        return None, 0.0
    
    def import_video(self, video):
        """Import a single video - match or store as pending"""
        doc_id, score = self.find_matching_document(video)
        
        cursor = self.db.cursor()
        
        if doc_id:
            # Match found - update document
            cursor.execute("""
                UPDATE documents 
                SET youtube_url = ?, 
                    youtube_video_id = ?
                WHERE id = ?
            """, (video['url'], video['video_id'], doc_id))
            
            self.matched.append({
                'video': video,
                'doc_id': doc_id,
                'score': score
            })
        else:
            # No match - store as pending
            cursor.execute("""
                INSERT INTO pending_youtube_videos 
                (video_title, youtube_url, youtube_video_id, playlist_name, season_number)
                VALUES (?, ?, ?, ?, ?)
            """, (video['title'], video['url'], video['video_id'], 
                  video['playlist_name'], video['season_number']))
            
            self.pending.append(video)
        
        self.db.commit()
    
    def import_from_folder(self, folder_path):
        """Import all .txt files from a folder"""
        folder = Path(folder_path)
        txt_files = list(folder.glob('*.txt'))
        
        print(f"Found {len(txt_files)} .txt files to import\n")
        
        for txt_file in txt_files:
            print(f"Processing {txt_file.name}...")
            videos = self.parse_txt_file(txt_file)
            
            for video in videos:
                self.import_video(video)
            
            print(f"  âœ… Processed {len(videos)} videos\n")
        
        self.print_report()
    
    def print_report(self):
        """Print detailed import report"""
        print("\n" + "="*60)
        print("YOUTUBE IMPORT REPORT")
        print("="*60)
        
        print(f"\nâœ… MATCHED: {len(self.matched)} videos")
        if self.matched:
            print("\nTop matches:")
            for item in self.matched[:10]:
                print(f"  â€¢ {item['video']['title'][:60]}")
                print(f"    Score: {item['score']:.0%}, Doc ID: {item['doc_id']}")
        
        print(f"\nâ³ PENDING: {len(self.pending)} videos (waiting for transcripts)")
        if self.pending:
            print("\nPending videos:")
            for video in self.pending[:10]:
                print(f"  â€¢ {video['title'][:60]}")
                print(f"    Playlist: {video['playlist_name']}")
        
        print("\n" + "="*60)
        print(f"TOTAL: {len(self.matched) + len(self.pending)} videos imported")
        print("="*60 + "\n")

# USAGE
if __name__ == '__main__':
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python import_youtube_urls.py <folder_with_txt_files>")
        sys.exit(1)
    
    folder = sys.argv[1]
    importer = YouTubeImporter()
    importer.import_from_folder(folder)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
STEP 3: AUTO-LINKING ON UPLOAD
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Modify upload handler to check for pending YouTube videos:

File: app.py (or wherever upload endpoint is)

@app.route('/api/upload', methods=['POST'])
def upload_document():
    # ... existing upload logic ...
    
    # After document is saved to database
    doc_id = cursor.lastrowid
    filename = file.filename
    
    # NEW: Check for pending YouTube videos that match this filename
    cursor.execute("""
        SELECT id, youtube_url, youtube_video_id, video_title
        FROM pending_youtube_videos
        WHERE matched_to_document_id IS NULL
    """)
    
    pending_videos = cursor.fetchall()
    
    best_match = None
    best_score = 0.0
    
    for vid_id, url, video_id, title in pending_videos:
        # Calculate similarity
        score = calculate_similarity(filename, title)
        
        if score > best_score:
            best_score = score
            best_match = (vid_id, url, video_id)
    
    # If good match found (70%+), link them
    if best_match and best_score >= 0.70:
        vid_id, url, video_id = best_match
        
        # Update document with YouTube URL
        cursor.execute("""
            UPDATE documents
            SET youtube_url = ?, youtube_video_id = ?
            WHERE id = ?
        """, (url, video_id, doc_id))
        
        # Mark pending video as matched
        cursor.execute("""
            UPDATE pending_youtube_videos
            SET matched_to_document_id = ?
            WHERE id = ?
        """, (doc_id, vid_id))
        
        db.commit()
        
        # Include in response
        return jsonify({
            'success': True,
            'document_id': doc_id,
            'youtube_linked': True,
            'youtube_url': url,
            'match_score': best_score
        })
    
    # ... existing return statement ...

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
STEP 4: UI ENHANCEMENTS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

A) Upload form shows YouTube linking status:

When user uploads PDF:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ âœ… Document uploaded successfully   â”‚
â”‚                                     â”‚
â”‚ ğŸ¥ YouTube video auto-linked!       â”‚
â”‚ Match confidence: 85%               â”‚
â”‚                                     â”‚
â”‚ [VIEW DOCUMENT] [WATCH VIDEO]       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

B) Content Atlas shows YouTube status:

Document cards show:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“„ Season 17.2 - Crusader Types    â”‚
â”‚                                     â”‚
â”‚ ğŸ¥ YouTube: Linked âœ…               â”‚
â”‚ [WATCH VIDEO] [VIEW TRANSCRIPT]     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Or if no YouTube:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ“„ Season 32 - ENFP Octagram       â”‚
â”‚                                     â”‚
â”‚ ğŸ¥ YouTube: Not linked              â”‚
â”‚ [ADD YOUTUBE URL]                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

C) Pending videos dashboard (new page):

/pending-youtube-videos

Shows all videos waiting for transcripts:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ â³ PENDING YOUTUBE VIDEOS (190)     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Season 1 - Jungian Cognitive...    â”‚
â”‚ https://youtube.com/watch?v=...    â”‚
â”‚ [MARK AS MATCHED]                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Season 2 - Function Stack Intro    â”‚
â”‚ https://youtube.com/watch?v=...    â”‚
â”‚ [MARK AS MATCHED]                   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
STEP 5: TESTING CHECKLIST
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

â–¡ Database migrations run successfully
â–¡ Import script parses .txt files correctly
â–¡ Matching algorithm finds existing PDFs (test with known matches)
â–¡ Unmatched videos stored in pending table
â–¡ Auto-linking works on new uploads
â–¡ UI shows YouTube status correctly
â–¡ Pending videos dashboard displays correctly

TEST DATA:
Create a test folder with 2-3 .txt files from bookmarklet
Run import script
Verify some match existing PDFs, some go to pending
Upload a new PDF that matches a pending video
Verify auto-linking occurs

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
IMPLEMENTATION ORDER
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

1. Run database migrations (add columns + pending table)
2. Create import script (scripts/import_youtube_urls.py)
3. Test import with sample .txt files
4. Add auto-linking to upload handler
5. Test auto-linking with new upload
6. Add UI enhancements to Content Atlas
7. Create pending videos dashboard
8. Full system test

ESTIMATED TIME: 2-3 hours

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
NOTES FOR REPLIT AGENT
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

- Use existing database connection patterns
- Follow existing code style and structure
- The .txt files will be in a user-specified folder
- Similarity matching threshold is 70% (tunable if needed)
- Video IDs are extracted from URLs (watch?v=VIDEO_ID)
- Auto-linking happens silently on upload (no user action needed)
- Pending dashboard is optional nice-to-have (core functionality works without it)

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
SUCCESS CRITERIA
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

âœ… User can extract YouTube URLs using bookmarklet
âœ… User can run import script on folder of .txt files
âœ… System matches videos to existing PDFs automatically
âœ… Unmatched videos stored for future linking
âœ… New PDF uploads auto-link to pending videos
âœ… User can see YouTube status in Content Atlas
âœ… All 900+ videos can be imported and tracked